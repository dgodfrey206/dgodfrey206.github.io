
<!DOCTYPE html>
<html>
<head>
    <title>C++ Streams API</title>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="styles/monokai_sublime.css">
    <link rel="stylesheet" href="styles/api.css">
    <script src="scripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/javascript" src="scripts/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="scripts/api.js"></script>
</head>
<body>
<div id="sidebar">
   <!--  <a href="#" class="sidebar-title">C++ Streams</a>
    <a href="#intro" class="sidebar-title">Introduction</a>
    <a href="#recipes" class="sidebar-title">Recipes</a> -->
</div>
<div id="content">
    <div id="title">C++ Streams API</div>

    <div id="links">
        <a href="https://github.com/dgodfrey206/dgodfrey206/archive/master.zip">Download Streams</a>
        <span class="sep">|</span>
        <a href="https://github.com/dgodfrey206/Streams">Github Page</a>
        <span class="sep">|</span>
        <a href="index.html">Home Page</a>
    </div>

    <p>Streams is a C++ library that provides lazy evaluation and functional-style
    transformations on data, to ease the use of C++ standard library containers
    and algorithms. Streams support many common functional operations such as
    map, filter, and reduce, as well as various other useful operations such as
    various set operations (union, intersection, difference), partial sum, and
    adjacent difference, as well as many others.
    Please visit the <a target="blank" href="https://github.com/dgodfrey206/Streams">Github</a>
    page to download and try it yourself.</p>

    <p>Streams is developed by David Godfrey,
    and is always looking to improve. Please get in touch if you find bugs or have ideas on
    how to make Streams even better.</p>

    <p>To use streams <a target="blank" href="https://github.com/dgodfrey206/Streams/archive/master.zip">download</a>
    them from Github. To use, simply <span class="inline">#include "Stream.h"</span>.
    Streams require <b>C++14</b> to compile. Streams consist only of header files, so you
    shouldn't have to modify your build process to use them. </p>

    <h2 id="intro">Introduction</h2>

    <div class="note">
    <b>Note:</b> Everything in the Streams library is enclosed within the
    <span class="inline">stream</span> namespace. Additionally, all stream operators
    and (terminal and intermediate) are in the <span class="inline">stream::op</span>
    namespace, which has not been hidden. For the sake of readability and
    brevity, these have been excluded here (assume an implicit <span class="inline">
    using namespace stream;</span> and a <span class="inline">using namespace stream::op</span>
    in all of the examples).
    </div>

    <p>Streams are an abstraction on a set of data that has a specific order (be it
    a strict ordering or just some encounter order). Various operations can
    be applied to streams such that data passes through the stream pipeline in
    a lazy manner, only getting passed to then next operation when it is requested.
    There are 3 main kinds of stream operations: generators, intermediate operators,
    and terminal operators.
    </p>

    <ul>
        <li><a href="#generators">Generators</a> are methods that create streams, and are
        thus considered stream sources. Stream generators will not be evaluated at all until
        some terminal operation on a stream has been called.</li>
        <li>Intermediate operators take in streams and return streams, applying some additional
        operation to the end of the stream pipeline. Intermediate operations will not be evaluated
        until some terminal operation on the stream has been called. There are two kinds of
        intermediate operators: <a href="#stateless">stateless</a> and
        <a href="#stateful">stateful</a>. Stateless operators require <i>O(1)</i> memory, whereas
        stateful operators may accumulate up to <i>O(n)</i> memory where <i>n</i> is the stream length.</li>
        <li><a href="#terminals">Terminal operators</a> close a stream and finally cause all of the
        stream operations to evaluate up the stream pipeline, until some final non-stream value
        gets returned by the terminal operation.</li>
    </ul>

    <p>A stream is a single source of data, and thus will uniquely own its data source.
    There is no way of copying streams without accruing a lot of state and thus
    streams are not copiable. However, streams are movable. Moving a stream will
    result in the source stream being "vacant." One can check the vacancy of
    a stream using the <span class="inline"><a href="#occupied">occupied()</a></span>
    method. Attempting to apply <b>any</b> stream operation to a vacant stream
    will result in a <span class="inline">VacantStreamException</span> being
    thrown. Additionally, all intermediate operations will create new streams
    which now own the original data source of the calling stream. Thus calling
    and intermediate operation on a stream will result in the original stream
    being vacant. See the example for <span class="inline">
    <a href="#occupied">occupied()</a></span>.</p>

    <p>Streams can be iterated through in the standard C++ way using the
    <span class="inline"><a href="#begin">begin()</a></span> and
    <span class="inline"><a href="#begin">end()</a></span> methods. However,
    one should be careful when using these (as they don't work exactly like
    standard library iterators), and using these may not be as efficient. For
    example, even though it may be nicer to iterate through a stream via
    a range-for loop, it may be more efficient to use the <span class="inline">
    <a href="#for_each">for_each()</a></span> method, as it does not have to
    incur the overhead cost of making stream iterators safe to use.
    </p>

    <h3>Operator Application and Composition</h3>

    <p>Stream operators are objects that can be applied to streams to alter the contents
    (usually) in a lazy value, or to compute a terminal result. Most of the library
    consists of functions which return stream operators that can be applied to a
    stream using the bitwise or operator, <span class="inline">|</span> as follows:
    <span class="inline">stream | streamop</span>. These operations can be chained:
    <span class="inline">stream | op1 | op2 | ... | opN</span>. Most operations can applied
    to streams of many types.</p>

    <p>Stream opeartors can also be composed with one another, to create new stream
    operators. Thus, application of streams is associative. For example,
    <span class="inline">stream | op1 | op2 | op3</span> is
    equivalent to <span class="inline">stream | (op1 | op2 | op3)</span> or
    <span class="inline">stream | (op1 | op2) | op3</span> or
    <span class="inline">stream | op1 | (op2 | op3)</span>. This means the creation
    of new stream operators is quite easy:
    </p>

    <p>
        <pre class="outside">
            <code lang="C++">auto square_and_sum = map_([] (auto x) { return x * x; }) | sum();</code>
        </pre>
    </p>

    <h3>Specializations</h3>

    <p>Streams are specialized based on the element type of the stream to allow extended
    functionality based on that type. Specializations for most types are listed in their
    relevant sections. However, for class types, there are specializations that are
    further reaching, and we shall discuss here. For any method that takes function of
    the element type (e.g. <span class="inline"><a href="#map">map_()</a></span>,
    <span class="inline"><a href="#filter">filter()</a></span>, <span class="inline">
    <a href="#take_while">take_while()</a></span>, to name a few), there is a specialization
    that allows for passing member function pointers to the function. For example consider
    the following example:
    </p>

    <p>
        <pre class="outside">
            <code lang="C++">struct Thing {
    int x;
    int value() const { return x }
};
Stream&lt;Thing&gt; things = /* ... */</code>
        </pre>
    </p>

    <p>In this case, all of the following are equivalent, with the last one being the one
    that is provided by the stream specialization for class types:</p>

    <pre class="outside">
        <code lang="C++">auto values = things | map_([](Thing&& thing) { return thing.value(); });
auto values = things | map_(std::mem_fn(&Thing::value));
auto values = things | map_(&Thing::value);</code>
    </pre>

    The full set of operators with this property is as follows:

    <ul>
        <li><span class="inline"><a href="#filter">filter()</a></span></li>
        <li><span class="inline"><a href="#take_while">take_while()</a></span></li>
        <li><span class="inline"><a href="#drop_while">drop_while()</a></span></li>
        <li><span class="inline"><a href="#map">map_()</a></span></li>
        <li><span class="inline"><a href="#flat_map">flat_map()</a></span></li>
        <li><span class="inline"><a href="#peek">peek()</a></span></li>
        <li><span class="inline"><a href="#for_each">for_each()</a></span></li>
        <li><span class="inline"><a href="#any">any()</a></span></li>
        <li><span class="inline"><a href="#all">all()</a></span></li>
        <li><span class="inline"><a href="#none">none()</a></span></li>
        <li><span class="inline"><a href="#not_all">not_all()</a></span></li>
    </ul>

    <h2 id="methods">Methods</h2>

    <p>These are methods on the stream class that do not directly effect the data in
    the stream, and thus are not considered stream operators.</p>

    <div class="function method" id="begin">
        <div class="fheader">
            <span class="fname">::begin()</span>
            <span class="fdescriptor">Stream method<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">iterator Stream&lt;T&gt;::begin();</code>
            </pre>

            Returns an iterator to the beginning of the stream.
            Iterators for streams have all of the standard iterator operator overloads,
            and act for the most part just like normal forward iterators. However,
            there are some caveats to their use.<br/><br/>

            First of all, when getting a starting iterator from <span class="inline">
            begin()</span>, you have not yet consumed anything in the stream. But,
            as soon as you perform some operation (dereference, increment, test equality
            or inequality) on this. iterator, the first element of the stream (if there
            is one) will be consumed and this iterator will resolve itself to its actual
            value. Example:

            <pre>
                <code lang="C++">auto stream = MakeStream::counter(1)
    | peek([](int x) { std::cout << "Peek = " << x << "\n" });
auto iter = stream.begin();
int value = *iter;
std::cout << "Iter = " << value << "\n";</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">Peek = 1
Iter = 1</code>
            </pre>

            Second, be very careful when using the return value of the postfix increment
            operator. The return value of the postfix increment of an iterator is an iterator
            that is consider to be "consumed," meaning you can dereference it, but you
            can't do anything else with it, you can't increment it or check its equality.
            <br/><br/>

            Why is this? Well the idea is that we don't want to split the stream or
            copy it. If you had two independent iterators that were both attempting to
            iterate through the same stream, very strange behavior could occur, because
            a stream isn't a true container, its simply an wrapper around a next method.
            This isn't to say getting two iterators is impossible (simply call
            <span class="inline">begin()</span> twice). However, we want to safeguard
            against this type of behavior. Attempting to perform unauthorized actions on
            a consumed iterator results in a <span class="inline"><a href="#consumedexception">
            ConsumedIteratorException</a></span>. Example:

            <pre>
                <code lang="C++">auto stream = MakeStream::closed_range(1, 10);
auto iter = stream.begin();
cout << *iter << endl;
auto temp_iter = iter++;
cout << *temp_iter << endl;
try {
    ++temp_iter;
} catch(ConsumedIteratorException& e) {
    cout << e.what() << endl;
}</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">1
2
Cannot perform prefix increment on consumed stream iterator.</code>
            </pre>

            That being said, using stream iterators should be fine with most if not
            all standard library algorithms. However, be cognizant of the fact that
            you are paying a slight overhead cost for using an iterator, so if
            speed is your concern, use a reduction method instead of something
            that uses iterators. For example, even though this is prettier:

            <pre>
                <code lang="C++">for(auto element : stream) {
    /* do something */
}</code>
            </pre>

            This is more efficient:

            <pre>
                <code lang="C++">stream | for_each([](auto element) {
    /* do something */
});</code>
            </pre>

            The choice is yours.
        </div>
    </div>

    <div class="function method" id="end">
        <div class="fheader">
            <span class="fname">::end()</span>
            <span class="fdescriptor">Stream method<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">iterator Stream&lt;T&gt;::end();</code>
            </pre>

            Returns an iterator to something one past the end of the stream. Since
            the end of the stream is unknown, this is simply a sentinel iterator.
            For a discussion of the intricacies of using iterators see the
            <span class="inline"><a href="#begin">begin()</a></span> method.
        </div>
    </div>

    <div class="function method" id="occupied">
        <div class="fheader">
            <span class="fname">::occupied()</span>
            <span class="fdescriptor">Stream method<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">bool Stream&lt;T&gt;::occupied();</code>
            </pre>

            Returns true if the stream object owns stream data. Streams are only
            movable (not copiable), and moving a stream results in a "vacant"
            stream (calling this method will return false). Attempting to
            perform any stream operation on a vacant stream will result in a
            <span class="inline">VacantStreamException</span>. Similarly, every
            stream operation returns a new stream that owns the data of the stream(s)
            it was called on. Thus attempting to do two operations on the same
            stream will result in an exception being thrown.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">Stream&lt;int&gt; stream1 = MakeStream::counter(1);
std::cout << std::boolalpha;
std::cout << "Stream 1 occupied: " << stream1.occupied() << std::endl;
Stream&lt;int&gt; stream2 = stream1 | limit(10);
std::cout << "Stream 1 occupied: " << stream1.occupied() << std::endl;
std::cout << "Stream 2 occupied: " << stream2.occupied() << std::endl;
try {
    stream1 | filter([] (int x) { return x % 2 == 0; })
} catch(VacantStreamException& e) {
    std::cout << e.what() << std::endl;
}</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">Stream 1 occupied: true
Stream 1 occupied: false
Stream 2 occupied: true
Cannot call stream::op::filter on a vacant stream</code>
            </pre>
        </div>
    </div>

    <div class="function method" id="close">
        <div class="fheader">
            <span class="fname">::close()</span>
            <span class="fdescriptor">Stream method</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">void Stream&lt;T&gt;::close();</code>
            </pre>

            Closes a stream, causing all of its unevaluated data to be lost, and
            the stream will be but into a vacant state. This is called automatically
            after any terminal operation.

            <br><br>
            <i>Example:</i>

            <pre>
                <code lang="C++">auto s = MakeStream::counter(1);
s.close();
s.occupied(); // returns false</code>
            </pre>
        </div>
    </div>

    <div class="function method" id="pipeline">
        <div class="fheader">
            <span class="fname">::pipeline()</span>
            <span class="fdescriptor">Stream method<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">std::string Stream&lt;T&gt;::pipeline();</code>
            </pre>

            Returns a string representation of the stream pipeline, including all of the basic
            transformations on the stream and all sources, the number
            of pipelines, and the number of stream sources.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">std::vector&lt;std::string&gt; v = /* ... */
auto s = MakeStream::from(v)
    | limit(100)
    | filter([](std::string& s) { return !s.empty(); })
    | map_([](std::string& s) { return s[0]; })
    | zip_with(MakeStream::counter(1) * 5)
    | zip_with(MakeStream::repeat(10));
std::cout << s.pipeline() << std::endl</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">&gt; Zip:
  &gt; Zip:
    &gt; Map:
      &gt; Filter:
        &gt; Slice[0, 100, 1]:
          &gt; [iterator stream]
    &gt; Map:
      &gt; [iterated stream]
  &gt; [repeated value stream]
Stream pipeline with 6 stages and 3 sources.</code>
            </pre>
        </div>
    </div>

    <h2 id="generators">Stream Generators</h2>

    <p>The stream generator factory methods can all be found as static methods
    in the <span class="inline">MakeStream</span> class. These are not wrapped in
    the stream, so that they can perform type deduction for you.</p>

    <p>
    Be careful when using factory methods that draw from referenced data sources (for example,
    <span class="inline"><a href="#from">MakeStream::from(const Container&)</a></span>). These
    are perfectly safe to use if the usage of the stream is entirely contained
    with in the current scope. However, if the scope is left, and the stream is referencing
    a container within that scope, bad stuff can happen. In this case, prefer
    the <span class="inline"><a href="#from_move">MakeStream::from_move()</a></span> generator.</p>

    <div class="function generator" id="empty">
        <div class="fheader">
            <span class="fname">::empty()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename T&gt;
Stream&lt;T&gt; MakeStream::empty();</code>
            </pre>

            Creates an empty stream of the given type. Calling
            <span class="inline">MakeStream::empty&lt;T&gt;()</span> is equivalent
            to default constructing a stream.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::empty&lt;int&gt;() | count(); // 0</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="singleton">
        <div class="fheader">
            <span class="fname">::singleton()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename T&gt;
Stream&lt;T&gt; MakeStream::singleton(T&& value);</code>
            </pre>

            Creates a stream with a single given value.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::singleton(5) | to_vector(); // {5}</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="from">
        <div class="fheader">
            <span class="fname">::from()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures (template definitions
            excluded for brevity):</span>
            <pre>
                <code lang="C++">Stream&lt;T&gt; MakeStream::from(Iterator begin, Iterator end);
Stream&lt;T&gt; MakeStream::from(const Container& cont);
Stream&lt;T&gt; MakeStream::from(T* arr, size_t length);
Stream&lt;T&gt; MakeStream::from(std::initializer_list&lt;T&gt; init);</code>
            </pre>

            Creates a stream from some existing set of data, a container for which
            <span class="inline">std::begin()</span>, and <span class="inline">std::end()</span> are defined, a C-style array or an initializer list.<br/><br/>

            <b>Warning!</b> Beware using most of these methods if your Stream is going to
            be used outside of the current scope. The exception to this is the
            <span class="inline">initializer_list</span> generator, which will capture
            the list, and therefore is safe to use outside of the current scope. To
            safely capture a container in a cycle, use the
            <span class="inline"><a href="#from_move">from_move()</a></span> generator method.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">std::vector&lt;int&gt; x = {1, 3, 4, 2};
MakeStream::from(x);
MakeStream::from(x.begin(), x.end())
int arr[4] = {1, 3, 4, 2};
MakeStream::from(arr, 4);
MakeStream::from({1, 3, 4, 2});</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="from_move">
        <div class="fheader">
            <span class="fname">::from_move()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Container&gt;
Stream&lt;T&gt; MakeStream::from_move(Container&& cont);</code>
            </pre>

            Creates a stream from a container of data, moving that container into
            itself, so that the stream may be used safely outside of the current scope.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">#include "Stream.h"
#include &lt;vector&gt;
#include &lt;iostream&gt;

std::vector&lt;int&gt; make_vector() {
    return {1, 2, 3};
}

Stream&lt;int&gt; make_stream_safe1() {
    return MakeStream::from_move(make_vector());
}

Stream&lt;int&gt; make_stream_safe2() {
    std::vector&lt;int&gt; vec = {4, 5, 6};
    return MakeStream::from_move(vec);
}

Stream&lt;int&gt; make_stream_unsafe() {
    std::vector&lt;int&gt; vec = {7, 8, 9};
    return MakeStream::from(vec); // BAD!
}

int main(int argc, char const *argv[]) {
    (make_stream_safe1()  | print_to(std::cout)) << std::endl;
    (make_stream_safe2()  | print_to(std::cout)) << std::endl;
    (make_stream_unsafe() | print_to(std::cout)) << std::endl;
}</code>
            </pre>

            Produces the following output (on one run on my computer):

            <pre>
                <code lang="C++">1 2 3
4 5 6
7 -536870912 -2026110050</code>
            </pre>

            Rule of thumb: If you're only going to be accessing data through the
            stream, probably just use <span class="inline">from_move()</span>.
        </div>
    </div>

    <div class="function generator" id="repeat">
        <div class="fheader">
            <span class="fname">::repeat()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">template&lt;typename T&gt;
Stream&lt;T&gt; MakeStream::repeat(T&& value);
template&lt;typename T&gt;
Stream&lt;T&gt; MakeStream::repeat(T&& value, size_t times);</code>
            </pre>

            Creates a stream consisting of the same value repeated over and
            over again. The first method creates an infinite stream of the repeated
            value. The second method only repeats the value a fixed number of
            times. Calling <span class="inline">MakeStream::repeat(x, n)</span> is
            equivalent to calling <span class="inline">MakeStream::repeat(x) | limit(n)</span>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">auto s = MakeStream::from({ /* ... */ })
    | concat(MakeStream::repeat(0)) // Stream padded with 0's</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="cycle">
        <div class="fheader">
            <span class="fname">::cycle()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures (template definitions
            excluded for brevity):</span>
            <pre>
                <code lang="C++">Stream&lt;T&gt; MakeStream::cycle(Iterator begin, Iterator end);
Stream&lt;T&gt; MakeStream::cycle(Iterator begin, Iterator end, size_t times);
Stream&lt;T&gt; MakeStream::cycle(const Container& cont);
Stream&lt;T&gt; MakeStream::cycle(const Container& cont, size_t times);
Stream&lt;T&gt; MakeStream::cycle(std::initializer_list&lt;T&gt; init);
Stream&lt;T&gt; MakeStream::cycle(std::initializer_list&lt;T&gt; init, size_t times); </code>
            </pre>

            Creates a stream of a sequence of elements repeated over and over again.
            The signatures without a <span class="inline">times</span> parameter
            will loop over a range indefinitely, whereas the ones with the parameter
            will only loop over the sequence that many times. <br/><br/>


            <b>Warning!</b> Beware using most of these methods if your Stream is going to
            be used outside of the current scope. The exception to this is the
            <span class="inline">initializer_list</span> generator, which will capture
            the list, and therefore is safe to use outside of the current scope. To
            safely capture a container in a cycle, use the
            <span class="inline"><a href="#cycle_move">cycle_move()</a></span>
            generator method.


            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">vector<int> x{1, 3, 8};
MakeStream::cycle(x.begin(), x.end()) // Contains 1, 3, 8, 1, 3, 8, 1, ...
MakeStream::cycle(x, 2) // Contains 1, 3, 8, 1, 3, 8.</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="cycle_move">
        <div class="fheader">
            <span class="fname">::cycle_move()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">template&lt;typename Container&gt;
Stream&lt;T&gt; MakeStream::cycle_move(Container&& cont);
template&lt;typename Container&gt;
Stream&lt;T&gt; MakeStream::cycle_move(Container&& cont, size_t times)</code>
            </pre>

            Creates a stream of a sequence of elements repeated over and over again.
            The signatures without a <span class="inline">times</span> parameter
            will loop over a range indefinitely, whereas the ones with the parameter
            will only loop over the sequence that many times. <br/><br/>

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">#include "Stream.h"
#include &lt;vector&gt;
#include &lt;iostream&gt;

std::vector&lt;int&gt; make_vector() {
    return {1, 2, 3};
}

Stream&lt;int&gt; make_stream_safe1() {
    return MakeStream::cycle_move(make_vector(), 2);
}

Stream&lt;int&gt; make_stream_safe2() {
    std::vector&lt;int&gt; vec = {4, 5, 6};
    return MakeStream::cycle_move(vec, 2);
}

Stream&lt;int&gt; make_stream_unsafe() {
    std::vector&lt;int&gt; vec = {7, 8, 9};
    return MakeStream::cycle(vec, 2); // BAD!
}

int main(int argc, char const *argv[]) {
    (make_stream_safe1()  | print_to(std::cout)) << std::endl;
    (make_stream_safe2()  | print_to(std::cout)) << std::endl;
    (make_stream_unsafe() | print_to(std::cout)) << std::endl;
}</code>
            </pre>

            Produces the following output (on one run on my computer):

            <pre>
                <code lang="C++">1 2 3 1 2 3
4 5 6 4 5 6
0 -1879048192 0 0 -1879048192 0</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="generate">
        <div class="fheader">
            <span class="fname">::generate()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Generator&gt;
Stream&lt;T&gt; MakeStream::generate(Generator&& generator);</code>
            </pre>

            Creates a stream whose values the return values of repeated calls to
            the generate function with no arguments.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::generate(rand); // Stream of random integers</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="iterate">
        <div class="fheader">
            <span class="fname">::iterate()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename T, typename Function&gt;
Stream&lt;T&gt; MakeStream::iterate(T&& value, Function&& function);</code>
            </pre>

            This is special case of <a href="#recurrence"><span class="inline">recurrence()</span></a>
            that creates a stream that, given a value <span class="inline">x</span> and
            a function <span class="inline">f</span> returns the stream produced by
            <span class="inline">x</span>, <span class="inline">f(x)</span>,
            <span class="inline">f(f(x))</span> and so on. In the below example
            we produce a stream which investigates the
            <a href="http://en.wikipedia.org/wiki/Collatz_conjecture" target="blank">Collatz conjecture</a>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">auto stream = MakeStream::iterate(1245, [](int x) {
    if(x % 2 == 0) {
        return x / 2;
    } else {
        return 3 * x + 1;
    }
});</code>
            </pre>

            Note that <span class="inline">iterate(n, f)</span> is a convenience for
            <span class="inline">recurrence(f, n)</span>.
        </div>
    </div>

    <div class="function generator" id="recurrence">
        <div class="fheader">
            <span class="fname">::recurrence()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename... Args, typename Function&gt;
Stream&lt;T&gt; MakeStream::recurrence(Function&& function, Args&&... initial);</code>
            </pre>

            A more general version of <a href="#iterate"><span class="inline">iterate()</span></a>,
            creates an infinite stream that is a recurrence relation starting with some initial
            set of values. For example for a second order recurrence relation (two initial values),
            the output of the stream would be: a<sub>1</sub>, a<sub>2</sub>,
            a<sub>3</sub> = f(a<sub>1</sub>, a<sub>2</sub>),
            a<sub>4</sub> = f(a<sub>2</sub>, a<sub>3</sub>),
            a<sub>5</sub> = f(a<sub>3</sub>, a<sub>4</sub>) ...

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::recurrence(std::plus&lt;int&gt;(), 0, 1); // 0 1 1 2 3 5 8 ...</code>
            </pre>

            Note that in the case that <span class="inline">sizeof...(Args) == 1</span>, this
            is identical to <a href="#iterate"><span class="inline">iterate()</span></a>.
        </div>
    </div>


    <div class="function generator" id="counter">
        <div class="fheader">
            <span class="fname">::counter()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">template&lt;typename T&gt;
Stream&lt;T&gt; MakeStream::counter(T&& start);
template&lt;typename T, typename U&gt;
Stream&lt;T&gt; MakeStream::counter(T&& start, U&& increment);
template&lt;typename T, typename U&gt;
Stream&lt;T&gt; MakeStream::counter(T&& start, const U& increment);</code>
            </pre>

            Creates a stream of elements produced by incrementing a given element
            indefinitely. Incrementing in the case of the first method is done
            via a prefix increment operator. The last two methods increment by a
            fixed value each time, by adding the increment to the current value
            (on the right side of the operator).

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1); // 1, 2, 3, 4, ...
MakeStream::counter('A', 2) // A, C, E, G, ...</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="range">
        <div class="fheader">
            <span class="fname">::range()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">template&lt;typename T&gt;
Stream&lt;T&gt; MakeStream::range(T&& lower, T&& upper);
template&lt;typename T, typename U&gt;
Stream&lt;T&gt; MakeStream::range(T&& lower, T&& upper, U&& increment);
template&lt;typename T, typename U&gt;
Stream&lt;T&gt; MakeStream::range(T&& lower, T&& upper, const U& increment);</code>
            </pre>

            Creates a stream of elements that iterate through a range starting at
            <span class="inline">lower</span>, up to but not including
            <span class="inline">upper</span>. Testing against the upper bound
            is done via the built in <span class="inline">!=</span> operator.
            The rules of incrementation for this method are identical to those of
            <span class="inline"><a href="#counter">counter()</a></span>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::range(0, 5); // 0, 1, 2, 3, 4
MakeStream::range(0, 8, 2); // 0, 2, 4, 6 </code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="closed_range">
        <div class="fheader">
            <span class="fname">::closed_range()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">template&lt;typename T&gt;
Stream&lt;T&gt; MakeStream::closed_range(T&& lower, T&& upper);
template&lt;typename T, typename U&gt;
Stream&lt;T&gt; MakeStream::closed_range(T&& lower, T&& upper, U&& increment);
template&lt;typename T, typename U&gt;
Stream&lt;T&gt; MakeStream::closed_range(T&& lower, T&& upper, const U& increment);</code>
            </pre>

            Creates a stream of elements that iterate through a range starting at
            <span class="inline">lower</span>, up <i>and</i> including
            <span class="inline">upper</span>. Testing against the upper bound
            is done via the built in <span class="inline">&lt;=</span> operator.
            The rules of incrementation for this method are identical to those of
            <span class="inline"><a href="#counter">counter()</a></span>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::closed_range(1, 5); // 1, 2, 3, 4, 5
MakeStream::closed_range(0, 8, 2); // 0, 2, 4, 6, 8</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="coin_flips">
        <div class="fheader">
            <span class="fname">::coin_flips()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename T = bool,
         typename Engine = std::default_random_engine&gt;
Stream&lt;T&gt; MakeStream::coin_flips();
template&lt;typename T = bool,
         typename Engine = std::default_random_engine,
         typename Seed&gt;
Stream&lt;T&gt; MakeStream::coin_flips(Seed&& seed);</code>
            </pre>

            Creates an infinite stream of random integers whose values are uniformly 0 or 1.
            The user can specify the underlying random engine which defaults to
            <span class="inline">std::default_random_engine</span> and the initial
            seed of the random number generator. If not given, the seed will be
            initialized to the current time. By default, this returns a stream of
            <span class="inline">bool</span>s, though the type can be specified
            as any time which makes sense.

            <br/><br/>
            <i>Example:</i>
            <br/><br/>

            The following runs a test to see how many coin flips come up heads
            after 1000 flips.

            <pre>
                <code lang="C++">int heads = MakeStream::coin_flips()
    | limit(1000)
    | filter()
    | count();</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="uniform_random_ints">
        <div class="fheader">
            <span class="fname">::uniform_random_ints()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename T,
         typename Engine = std::default_random_engine&gt;
Stream&lt;T&gt; MakeStream::uniform_random_ints(T lower, T upper);
template&lt;typename T,
         typename Engine = std::default_random_engine,
         typename Seed&gt;
Stream&lt;T&gt; MakeStream::uniform_random_ints(T lower, T upper, Seed&& seed);</code>
            </pre>

            Creates an infinite stream of random integers whose values are distributed uniformly
            between the upper and lower bounds. The user can specify the underlying
            random engine which defaults to <span class="inline">std::default_random_engine</span>
            and the initial seed of the random number generator. If not given, the seed will be
            initialized to the current time.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::uniform_random_ints(0, 10);</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="uniform_random_reals">
        <div class="fheader">
            <span class="fname">::uniform_random_reals()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename T = double,
         typename Engine = std::default_random_engine&gt;
Stream&lt;T&gt; MakeStream::uniform_random_reals(T lower = 0.0, T upper = 1.0);
template&lt;typename T,
         typename Engine = std::default_random_engine,
         typename Seed&gt;
Stream&lt;T&gt; MakeStream::uniform_random_reals(T lower, T upper, Seed&& seed);</code>
            </pre>

            Creates an infinite stream of random real numbers whose values are
            distributed uniformly between the upper and lower bounds. The first
            signature defaults the lower and upper bounds to 0 and 1 respectively.
            The user can specify the underlying random engine which defaults to
            <span class="inline">std::default_random_engine</span> and the initial
            seed of the random number generator. If not given, the seed will be
            initialized to the current time.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::uniform_random_reals(); // Doubles between 0 and 1
MakeStream::uniform_random_reals&lt;float>(.3, .7); // Floats between .3 and .7</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="normal_randoms">
        <div class="fheader">
            <span class="fname">::normal_randoms()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename T = double,
         typename Engine = std::default_random_engine&gt;
Stream&lt;T&gt; MakeStream::normal_randoms(T mean = 0.0, T stddev = 1.0);
template&lt;typename T = double,
         typename Engine = std::default_random_engine,
         typename Seed&gt;
Stream&lt;T&gt; MakeStream::normal_randoms(T mean, T stddev, Seed&& seed);</code>
            </pre>

            Creates an infinite stream of random real numbers whose values are normally
            distributed with a given mean and stand deviation. The first signature
            defaults the parameters to the standard normal distribution, <i>&mu;</i> = 0
            and <i>s</i> = 1.
            The user can specify the underlying random engine which defaults to
            <span class="inline">std::default_random_engine</span> and the initial
            seed of the random number generator. If not given, the seed will be
            initialized to the current time.
            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::normal_randoms(); // Doubles distributed normally
MakeStream::normal_randoms&lt;float>(5.3, 1.8); // Floats distributed normally.</code>
            </pre>
        </div>
    </div>

    <div class="function generator" id="randoms">
        <div class="fheader">
            <span class="fname">::randoms()</span>
            <span class="fdescriptor">Stream generator<br/></span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">template&lt;typename T,
         template&lt;typename&gt; class Distribution,
         typename Engine = std::default_random_engine,
         typename Seed,
         typename... GenArgs&gt;
Stream&lt;T&gt; MakeStream::randoms(Seed&& seed, GenArgs&&... args);
template&lt;typename T,
         template&lt;typename&gt; class Distribution,
         typename Engine = std::default_random_engine,
         typename... GenArgs&gt;
Stream&lt;T&gt; MakeStream::randoms(GenArgs&&... args);</code>
            </pre>

            Creates an infinite stream of random values as generically as possible.
            In this function, <span class="inline">T</span> is the type of the resulting
            stream, <span class="inline">Distribution</span> is an unqualified number
            distribution (e.g. <span class="inline">std::uniform_int_distribution</span>),
            <span class="inline">Engine</span> is the underlying random number generator
            and the <span class="inline">args...</span> are the parameters passed into
            the constructor of the number generator. If the seed is not provided,
            the current time will be used.

            If there is no factory method that supports your specific distribution, this
            is the method for you.
            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::randoms&lt;double, std::poisson_distribution&gt;(5.0);
// Stream of doubles coming from a poisson process with mean 5.</code>
            </pre>
        </div>
    </div>

    <h2 id="stateless">Stateless Intermediate Stream Operators</h2>

    <p>These operators insert another stage of a stream pipeline or combine
    two streams in some way forming a new stream, which contains the data of
    the old streams. Intermediate operators do not get evaluated until some
    terminal operation is called on the stream. These operators are all methods
    on the <span class="inline">Stream</span> class.</p>

    <div class="function stateless operator" id="filter">
        <div class="fheader">
            <span class="fname">filter()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Predicate&gt;
auto filter(Predicate&& predicate);</code>
            </pre>

            Returns a stream operator that only allows elements of the stream that pass the given predicate.
            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | filter([](int x) { return x % 2 == 0; });
// Stream now contains only even positive integers </code>
            </pre>

            <b>Specializations:</b><br/><br/>

            Specializations of <span class="inline">filter</span> exist for
            types that have an implicit conversion to <span class="inline">bool</span>.
            In this case, <span class="inline">filter()</span> returns a stream operator
            which will filter for values whose <span class="inline">bool</span>
            value is <span class="inline">true</span>. See the example for
            <span class="inline"><a href="#coin_flips">coin_flips()</a></span>.

        </div>
    </div>

    <div class="function stateless operator" id="map">
        <div class="fheader">
            <span class="fname">map_()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Transform&gt;
auto map_(Transform&& transform);</code>
            </pre>

            Returns a stream operator that transforms each element of the stream using the given transformation
            function. The resulting stream is the produced by applying the
            transformation to each element of the input stream.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | map_([](int x) { return x * x; });
// Stream of perfect squares</code>
            </pre>

        </div>
    </div>

    <div class="function stateless operator" id="flat_map">
        <div class="fheader">
            <span class="fname">flat_map()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Transform&gt;
auto flat_map(Transform&& transform);</code>
            </pre>

            Returns a stream operator that applies a transformation that is
            expected to return a stream as a result to every element of the stream.
            The resulting stream is the concatenation of these output streams.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | flat_map([](int x) {
        return MakeStream::counter(1) | limit(x);
    }); // Stream contains 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, ...</code>
            </pre>

        </div>
    </div>

    <div class="function stateless operator" id="limit">
        <div class="fheader">
            <span class="fname">limit()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto limit(size_t bound);</code>
            </pre>

            Returns a stream operator that ensures that the stream contains a maximum number of elements.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::uniform_random_ints(1, 10)
    | limit(5); // Stream contains 5 random integers</code>
            </pre>

            Note that <span class="inline">stream | limit(n)</span> is equivalent to
            <span class="inline">stream | slice(0, n, 1);</span>.

        </div>
    </div>

    <div class="function stateless operator" id="skip">
        <div class="fheader">
            <span class="fname">skip()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto skip(size_t amount);</code>
            </pre>

            Returns a stream operator that skips the first <i>k</i> elements of a stream.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | skip(10); // Stream contains 11, 12, 13, ...</code>
            </pre>

            Note that <span class="inline">stream | skip(n)</span> is equivalent to
            <span class="inline">stream | slice_to_end(n, 1);</span>.

        </div>
    </div>

    <div class="function stateless operator" id="slice">
        <div class="fheader">
            <span class="fname">slice()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto slice(size_t startIndex,
           size_t endIndex,
           size_t increment = 1);</code>
            </pre>

            Returns a stream operator that retrieves elements of the stream starting at <span class="inline">startIndex</span>,
            up to, but not including, <span class="inline">endIndex</span>, iterating
            by <span class="inline">increment</span>. By default, <span class="inline">increment</span>
            is 1.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">auto stream1 = MakeStream::counter(0) | slice(5, 10); // 5 6 7 8 9
auto stream2 = MakeStream::counter(0) | slice(1, 8, 2); // 1 3 5 7</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="slice_to_end">
        <div class="fheader">
            <span class="fname">slice_to_end()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto slice_to_end(size_t startIndex, size_t increment);</code>
            </pre>

            Returns a stream operator that is a version of the slice operation which allows an unbounded slice.
            Slices are taken starting at <span class="inline">startIndex</span>
            and go by <span class="inline">increment</span>.
            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">auto stream1 = MakeStream::counter(0) | slice_to_end(0, 5) // 0 5 10 15 ...
auto stream2 = MakeStream::counter(0) | slice_to_end(3, 2) // 3 5 7 9 ...</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="take_while">
        <div class="fheader">
            <span class="fname">take_while()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Predicate&gt;
auto take_while(Predicate&& predicate);</code>
            </pre>

            Returns a stream operator that takes elements from the stream until the given predicate becomes false.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | take_while([](int x) { return x < 5; });
// Stream contains 1, 2, 3, 4</code>
            </pre>

            <b>Specializations:</b><br/><br/>

            Specializations of <span class="inline">take_while</span> exist for
            types that have an implicit conversion to <span class="inline">bool</span>.
            In this case, <span class="inline">take_while()</span> returns a stream operator
            which will take values whose <span class="inline">bool</span>
            value is <span class="inline">true</span>.

        </div>
    </div>

    <div class="function stateless operator" id="drop_while">
        <div class="fheader">
            <span class="fname">drop_while()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Predicate&gt;
auto drop_while(Predicate&& predicate);</code>
            </pre>

            Returns a stream operator that drops the initial elements of the stream until the given predicate becomes
            false after which the stream is returned intact.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | drop_while([](int x) { return x < 5; });
// Stream contains 5, 6, 7, ...</code>
            </pre>

            <b>Specializations:</b><br/><br/>

            Specializations of <span class="inline">drop_while</span> exist for
            types that have an implicit conversion to <span class="inline">bool</span>.
            In this case, <span class="inline">drop_while()</span> returns a stream operator
            which will drop values whose <span class="inline">bool</span>
            value is <span class="inline">true</span>.
        </div>
    </div>

    <div class="function stateless operator" id="peek">
        <div class="fheader">
            <span class="fname">peek()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Function&gt;
auto peek(Function&& function);</code>
            </pre>

            Returns a stream operator that allows a lazy peek into the stream. When a value passes through the
            pipeline and hits a peek, the function will be called on that value,
            the functions return value is ignored and the original value is passed
            onto the next pipeline. Like all stateless operations, this will not
            be executed until some stateful or terminal operation is called on
            the stream.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">std::vector&lt;int&gt; result = MakeStream::counter(1)
    | filter([](int x) { x % 3 == 0; })
    | limit(3)
    | peek([](int x) { std::cout << "Value = " << x << std::endl; })
    | to_vector();</code>
            </pre>

            Output:

            <pre>
                <code class="output">Value = 3
Value = 6
Value = 9</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="adjacent_distinct">
        <div class="fheader">
            <span class="fname">adjacent_distinct()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Equal = std::equal_to&lt;void&gt;&gt;
auto adjacent_distinct(Equal&& equal = Equal());</code>
            </pre>

            Returns a stream operator that removes adjacent duplicates from the stream. By default, duplicates
            are determined using the standard <span class="inline">==</span>
            operator. However, a different equality operation can be given.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::from({1, 1, 3, 2, 2, 5, 5, 5, 5, 2, 3, 3})
    | adjacent_distinct(); // Stream contains 1, 3, 2, 5, 2, 3;</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="adjacent_difference">
        <div class="fheader">
            <span class="fname">adjacent_difference()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Subtract = std::minus&lt;void&gt;&gt;
auto adjacent_difference(Subtract&& subtract = Subtract());</code>
            </pre>

            Returns a stream operator that returns a stream of the pairwise differences of the elements.
            By default, subtraction is performed using the standard <span class="inline">-</span>
            operator. However, a different subtraction operation can be given. The type
            of the resulting stream is the difference type returned by the subtraction
            function.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | map_([](int x) { return x * x; })
    | adjacent_difference(); // Stream contains 3, 5, 7, 9, ...</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="partial_sum">
        <div class="fheader">
            <span class="fname">partial_sum()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Adder = std::plus&lt;T&gt;&gt;
auto partial_sum(Adder&& add = Adder());</code>
            </pre>

            Returns a stream operator that computes the partial sum of the elements in the stream. By default,
            addition is performed using the standard <span class="inline">+</span>
            operator. However, a different addition operation can be given. This
            addition operation must take elements of type <span class="inline">T</span>
            and return an element of type <span class="inline">T</span>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::from({1, 5, 3, 7, -2, 6})
    | partial_sum(); // Stream contains 1, 6, 9, 16, 14, 20</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="concat">
        <div class="fheader">
            <span class="fname">concat()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">template&lt;typename Iterator&gt;
auto concat(Iterator begin, Iterator end);
auto concat(Stream&lt;T&gt;&& tail);</code>
            </pre>

            Returns a stream operator that concatenates the given stream to the end of the
            stream it is applied to, to be processed when the current stream reaches its end. The first
            form of <span class="inline">concat</span> is a convenience for
            concatenating with
            <span class="inline">MakeStream::from(begin, end)</span>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">std::vector&lt;int&gt; x = {4, 5, 6};
std::vector&lt;int&gt; y = {1, 2, 3};
MakeStream::from(x)
    | concat(MakeStream::from(y)); // Stream contains 4, 5, 6, 1, 2, 3</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="zip_with">
        <div class="fheader">
            <span class="fname">zip_with()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Right, typename Function = Zipper&gt;
auto zip_with(Stream&lt;Right&gt;&& other,
              Function&& zipper = Function());</code>
            </pre>

            Returns a stream operator that zips two streams together using the provided function, stopping when
            either of the streams finishes. By default, the zipping function takes
            the two elements of the streams and returns a tuple of the two elements.
            This function is specialized so that if either stream is a stream of
            tuples, the resulting of the zipping function is the concatenation of
            the tuples (rather than nested tuples).

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">std::vector&lt;std::string&gt; input = {"Hello", "this", "is", "a", "stream"};
MakeStream::from(input)
    | zip_with(MakeStream::counter(1))// Stream&lt;std::tuple&lt;std::string, int&gt;&gt;
    | for_each([](std::tuple&lt;std::string, int&gt;&& tup) {
        std::cout << tup << std::endl;
    });</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">(Hello, 1)
(this, 2)
(is, 3)
(a, 4)
(stream, 5)</code>
            </pre>

            <i>Note:</i> As can be seen above, we've included an overload for
            <span class="inline">operator&lt;&lt;</span> for inserting tuples
            into I/O streams.<br/><br/>

            Zipping multiple times produces a concatenated tuple rather than nested tuples:

            <pre>
                <code lang="C++">MakeStream::counter(0)
    | zip_with(MakeStream::counter(10))
    | zip_with(MakeStream::counter(20))
// Stream is now a stream of std::tuple&lt;int, int, int&gt; which contains:
// (0, 10, 20), (1, 11, 21), (2, 12, 22), ...</code>
            </pre>

            One particularly nice tuple operation we've included is a function
            called <span class="inline">splat</span> which takes a function and
            returns a function that takes a tuple and splats that tuples elements
            in as the arguments to the function. For example:

            <pre>
                <code lang="C++">auto splatted = splat([](std::string x, int y) {
    return x.length() + y;
});
splatted(std::make_tuple("Hello", 5)); // returns 10</code>
            </pre>

            This is useful, because it makes working with zipped streams particularly easy.
            So instead of having to do the ugly and unreadable:

            <pre>
                <code lang="C++">MakeStream::counter(1))
    | zip_with(MakeStream::counter(11))
    | map_([](const std::tuple&lt;int, int&gt;& tup) {
        return std::get&lt;0&gt;(tup) * std::get&lt;1&gt;(1);
    });</code>
            </pre>

            You can now have the following:

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | zip_with(MakeStream::counter(11))
    | map_(splat([](int first, int second) {
        return first * second;
    }));</code>
            </pre>

            A different function can be used for zipping, as an excellent way of
            performing element-wise operations to combine streams. All of the
            binary operators have stream overloads that are effectively zips.
            For example, consider the multiplication operator, which can be
            implemented on two streams in the following way (its not quite this,
            but close):

            <pre>
                <code lang="C++">template&lt;typename L, typename R&gt;
auto operator* (Stream&lt;L&gt;&& left, Stream&lt;R&gt;&& right) {
    return left | zip_with(right, [](const L& lvalue, const R& rvalue) {
        return lvalue * rvalue;
    });
}</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="merge_with">
        <div class="fheader">
            <span class="fname">merge_with()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <i><b>Note:</b> This operator only applies to streams that are guaranteed
            to be sorted. Use on any other streams produces undefined results.</i>
            <br/><br/>
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;T&gt;>
auto merge_with(Stream&lt;T&gt;&& other, Less&& less = Less());</code>
            </pre>

            Returns a stream operator that computes the merging of two streams (the merge step in mergesort).
            By default, elements are compared using their built in
            <span class="inline">&lt;</span> operator. However, a different less
            than operator can be provided.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">Stream<int> left = MakeStream::from({1, 2, 4, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left | merge_with(right); // 1, 2, 2, 4, 4, 5, 12, 12, 13, 17, 17, 18</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="union_with">
        <div class="fheader">
            <span class="fname">union_with()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <i><b>Note:</b> This operator only applies to streams that are guaranteed
            to be sorted and distinct. Use on any other streams produces undefined
            results.</i>
            <br/><br/>
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;T&gt;>
auto union_with(Stream&lt;T&gt;&& other, Less&& less = Less());</code>
            </pre>

            Returns a stream operator that computes the set union of two streams.
            By default, elements are compared using their built in
            <span class="inline">&lt;</span> operator. However, a different less
            than operator can be provided.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left | union_with(right); // 1, 2, 4, 12, 13, 17, 18</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="intersection_with">
        <div class="fheader">
            <span class="fname">intersection_with()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <i><b>Note:</b> This operator only applies to streams that are guaranteed
            to be sorted and distinct. Use on any other streams produces undefined
            results.</i>
            <br/><br/>
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;T&gt;>
auto intersection_with(Stream&lt;T&gt;&& other, Less&& less = Less());</code>
            </pre>

            Returns a stream operator that computes the set intersection of two streams.
            By default, elements are compared using their built in
            <span class="inline">&lt;</span> operator. However, a different less
            than operator can be provided.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left | intersection_with(right); // 2, 12, 17</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="difference_with">
        <div class="fheader">
            <span class="fname">difference_with()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <i><b>Note:</b> This operator only applies to streams that are guaranteed
            to be sorted and distinct. Use on any other streams produces undefined
            results.</i>
            <br/><br/>
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;T&gt;>
auto difference_with(Stream&lt;T&gt;&& other, Less&& less = Less());</code>
            </pre>

            Returns a stream operator that computes the set difference of two streams, with the base stream as
            the left argument, and the argument stream as the right argument to
            the difference.
            By default, elements are compared using their built in
            <span class="inline">&lt;</span> operator. However, a different less
            than operator can be provided.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left | difference_with(right); // 1, 4, 13</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="symmetric_difference_with">
        <div class="fheader">
            <span class="fname">symmetric_difference_with()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <i><b>Note:</b> This operator only applies to streams that are guaranteed
            to be sorted and distinct. Use on any other streams produces undefined
            results.</i>
            <br/><br/>
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;T&gt;&gt;
auto symmetric_difference_with(Stream&lt;T&gt;&& other, Less&& less = Less());</code>
            </pre>

            Returns a stream operator that computes the set symmetric difference of two streams.
            By default, elements are compared using their built in
            <span class="inline">&lt;</span> operator. However, a different less
            than operator can be provided.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left | symmetric_difference_with(right); // 1, 4, 5, 13, 18</code>
            </pre>
        </div>
    </div>

    <div class="function stateless operator" id="pairwise">
        <div class="fheader">
            <span class="fname">pairwise()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">Stream&lt;std::pair&lt;T, T&gt;&gt; Stream&lt;T&gt;::pairwise();</code>
            </pre>

            Returns a stream operator that returns a stream with adjacent elements grouped into pairs.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | pairwise() // Stream contains (1, 2), (3, 4), (5, 6), ...</code>
            </pre>

            Note that this is a convenience for <span class="inline">stream | group&lt;2&gt;()</span>.
        </div>
    </div>

    <div class="function stateless operator" id="group">
        <div class="fheader">
            <span class="fname">group()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;size_t N&gt;
auto group();
auto group(size_t N);</code>
            </pre>

            Returns a stream operator that returns a stream with adjacent elements
            grouped into groups of size <span class="inline">N</span>. <span class="inline">N</span>
            can either be a compile time constant or a runtime value. In the former case,
            the resulting stream is a stream of <span class="inline">N</span>-tuples,
            all of whose elements are of the original stream type, <span class="inline">T</span>.
            In the latter case, the resulting stream is a stream of
            <span class="inline">std::vector&lt;T&gt;</span>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1) | group&lt;3&gt;() // (1, 2, 3), (4, 5, 6), ...
MakeStream::counter(1) | group(3) // [1, 2, 3], [4, 5, 6], ...</code>
            </pre>

            This is specialied for <span class="inline">N = 2</span>, so that
            the resulting stream is a stream of pairs rather than tuple. Calling
            <span class="inline">stream | group<2>()</span> is the same as calling
            <span class="inline">stream | pairwise()</span>.
        </div>
    </div>

    <div class="function stateless operator" id="overlap">
        <div class="fheader">
            <span class="fname">overlap()</span>
            <span class="fdescriptor">Statelesss intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;size_t N&gt;
auto overlap();
auto overlap(size_t N);</code>
            </pre>

            Returns a stream operator that returns a stream with overlapping adjacent elements
            grouped into groups of size <span class="inline">N</span>.
            <span class="inline">N</span> can either be a compile time constant or a runtime value.
            In the former case, the resulting stream is a stream of <span class="inline">N</span>-tuples,
            all of whose elements are of the original stream type, <span class="inline">T</span>.
            In the latter case, the resulting stream is a stream of <span class="inline">std::deque&lt;T&gt;</span>.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1) | overlap&lt;2&gt;() // (1, 2), (2, 3), (4, 5), (5, 6), ...
MakeStream::counter(1) | overlap&lt;3&gt;() // (1, 2, 3), (2, 3, 4), (4, 5, 6), ...
MakeStream::counter(1) | overlap(4)   // [1, 2, 3, 4], [2, 3, 4, 5], ...</code>
            </pre>

        </div>
    </div>

    <div class="function stateless operator" id="operator">
        <div class="fheader">
            <span class="fname">operator<i>?</i>()</span>
            <span class="fdescriptor">Stateless intermediate stream operator</span>
        </div>
        <div class="fcontent">

            Almost all C++ overloadable operators are overloaded to provide an
            algebra for streams, allowing easy element-wise operations on streams
            with both other streams and a given value. For some binary operator which
            we will denote as <span class="inline">$</span>, the following overloads
            are available:<br/><br/>

            <span class="signature">Method signatures (template definitions excluded for brevity):</span>
            <pre>
                <code lang="C++">Stream&lt;X&gt; operator$ (Stream&lt;L&gt;&& left, R&& right);
Stream&lt;X&gt; operator$ (L&& left, Stream&lt;R&gt;&& right);
Stream&lt;X&gt; operator$ (Stream&lt;L&gt;&& left, Stream&lt;R&gt;&& right);</code>
            </pre>

            The first two of these signatures provide mapping operations, applying the
            <span class="inline">$</span> operator to every element of the stream with
            the given value on the left or the right. For example:

            <pre>
                <code lang="C++">auto stream1 = MakeStream::counter(1.0) / 3.0; // 1/3, 2/3, 1, 4/3, ....
auto stream2 = 5 * MakeStream::counter(0); // 0, 5, 10, 15, ...</code>
            </pre>

            The third signature provides an zipping operation of the elements in
            both streams, using the <span class="inline">$</span> operator as
            the zipping function. For example, one can compute the dot product
            of two streams as follows:

            <pre>
                <code lang="C++">Stream&lt;double&gt; v1 = /* ... */, v2 = /* ... */;
double dot_product = (v1 * v2) | sum();</code>
            </pre>

            Unsupported overloadable binary operators:

            <ul>
                <li>Assignment operators, <span class="inline">=</span>,
                    <span class="inline">+=</span>,
                    <span class="inline">*=</span>, etc.</li>
                <li>Subscript operator, <span class="inline">[]</span> <i>(In consideration)</i></li>
                <li>Member pointer operator, <span class="inline">-&gt;*</span></li>
                <li>Comma operator, <span class="inline">,</span></li>
            </ul>

            Various unary operators are also supported on streams, providing mapping
            operations. For some unary operator <span class="inline">$</span>, the
            signature for the operator is as follows:<br/><br/>

            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">Stream&lt;X&gt; operator$ (Stream&lt;T&gt;&& stream);</code>
            </pre>

            This provides a mapping operation, applying the <span class="inline">$</span>
            operator to every element of the stream. For example, to deference a stream
            of pointers, we simply call <span class="inline">*stream</span>.<br/><br/>

            Unsupported overloadable unary operators:

            <ul>
                <li>Postfix/prefix increment/decrement operators,
                    <span class="inline">++</span>, <span class="inline">--</span></li>
                <li>Reference operator, <span class="inline">&</span></li>
                <li>Structure dereference operator, <span class="inline">-></span></li>
                <li>Conversion operator operator, <span class="inline">(type)</span></li>
            </ul>

            Other overloadable but unsupported operators:

            <ul>
                <li>Allocation operators, <span class="inline">new</span>, <span class="inline">new[]</span></li>
                <li>Deallocation operators, <span class="inline">delete</span>, <span class="inline">delete[]</span></li>
                <li>Function application, <span class="inline">(args...)</span> <i>(Coming soon!)</i></li>
            </ul>

        </div>
    </div>

    <!-- Intermediate stateful operations -->

    <h2 id="stateful">Stateful Intermediate Stream Operators</h2>

    <p>These operators insert another stage of a stream pipeline or combine
    two streams in some way forming a new stream, which contains the data of
    the old streams. These operations accumulate some non constant amount of space to
    store their necessary state.</p>

    <div class="function stateful operator" id="state_point">
        <div class="fheader">
            <span class="fname">state_point()</span>
            <span class="fdescriptor">Stateful intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto state_point();</code>
            </pre>

            Returns a stream operator that forces the stream to collect its state before continuing with operations. This
            is a good way to allow a complete peek into the data at a certain point in the
            stream pipeline.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::counter(1)
    | peek([](int x) { std::cout << "x = " << x << std::endl; })
    | limit(3)
    | state_point()
    | map_([](int x) { return 2 * x; })
    | for_each([](int x) {
        std::cout << "2x = " << x << std::endl;
    });</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">x = 1
x = 2
x = 3
2x = 2
2x = 4
2x = 6</code>
            </pre>

            Without the call to <span class="inline">state_point()</span>,
            the following would have been the output:

            <pre>
                <code class="output">x = 1
2x = 2
x = 2
2x = 4
x = 3
2x = 6</code>
            </pre>

            Note that calling <span class="inline">stream | state_point()</span> is
            functionally equivalent to calling
            <span class="inline">MakeStream::from(stream | to_deque())</span>.

        </div>
    </div>

    <div class="function stateful operator" id="sort">
        <div class="fheader">
            <span class="fname">sort()</span>
            <span class="fdescriptor">Stateful intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;void&gt;&gt;
auto sort(Less&& less = Less());</code>
            </pre>

            Returns a stream operator that sorts the elements of the streams, using the given less than. By default,
            uses the built in <span class="inline">&lt;</span> operator.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::from({3, 1, 5, 3, 2, 8})
    | sort(); // Stream contains 1, 2, 3, 3, 5, 8</code>
            </pre>
        </div>
    </div>

    <div class="function stateful operator" id="distinct">
        <div class="fheader">
            <span class="fname">distinct()</span>
            <span class="fdescriptor">Stateful intermediate stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;T&gt;&gt;
auto distinct(Less&& less = Less());</code>
            </pre>

            Returns a stream operator that removes duplicate elements from the stream and returns the results
            in sorted order.

            <br/><br/>
            <i>Example:</i>

            <pre>
                <code lang="C++">MakeStream::from({3, 1, 3, 5, 2, 5, 8, 8})
    | distinct(); // Stream contains 1 2 3 5 8</code>
            </pre>
        </div>
    </div>


    <!-- Terminal operations -->

    <h2 id="terminals">Terminal Stream Operators</h2>

    <div class="function terminator" id="count">
        <div class="fheader">
            <span class="fname">count()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto count();</code>
            </pre>

            Returns a stream terminator that returns the number of elements in the stream.
        </div>
    </div>

    <div class="function terminator" id="sum">
        <div class="fheader">
            <span class="fname">sum()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto sum(const T& identity);
auto sum();</code>
            </pre>

            Returns a stream terminator that adds the elements of the stream, returning the total. If no additive
            identity is provided and the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>. If an identity is
            provided and the stream is empty, the identity is returned.
        </div>
    </div>

    <div class="function terminator" id="product">
        <div class="fheader">
            <span class="fname">product()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto product(const T& identity);
auto product();</code>
            </pre>

            Returns a stream terminator that multiplies the elements of the strean, returning the product. If no multiplicative
            identity is provided and the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>. If an identity is
            provided and the stream is empty, the identity is returned.

        </div>
    </div>

    <div class="function terminator" id="min">
        <div class="fheader">
            <span class="fname">min()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;void&gt;&gt;
auto min(Less&& less = Less());</code>
            </pre>

            Returns a stream terminator that returns the smallest element of the stream as given by the provided
            less than operator (by default, the built in <span class="inline">&lt;</span>
            operator); If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="min_by">
        <div class="fheader">
            <span class="fname">min_by()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Function, typename Less = std::less&lt;void&gt;&gt;
auto min_by(Function&& function, Less&& less = Less());</code>
            </pre>

            Returns a stream terminator that returns the element of the stream that results in the smallest 
            value of the given function as determined by the provided less than operator (by default, the
            built in <span class="inline">&lt;</span> operator); If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="max">
        <div class="fheader">
            <span class="fname">max()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;void&gt;&gt;
auto max(Less&& less = Less());</code>
            </pre>

            Returns a stream terminator that returns the largest element of the stream as given by the provided
            less than operator (by default, the built in <span class="inline">&lt;</span>
            operator); If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="max_by">
        <div class="fheader">
            <span class="fname">max_by()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Function, typename Less = std::less&lt;void&gt;&gt;
auto max_by(Function&& function, Less&& less = Less());</code>
            </pre>

            Returns a stream terminator that returns the element of the stream that results in the largest 
            value of the given function as determined by the provided less than operator (by default, the
            built in <span class="inline">&lt;</span> operator); If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="minmax">
        <div class="fheader">
            <span class="fname">minmax()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Less = std::less&lt;T&gt;&gt;
auto minmax(Less&& less = Less());</code>
            </pre>

            Returns a stream terminator that returns the smallest and largest elements of the stream as given by the provided
            less than operator (by default, the built in <span class="inline">&lt;</span>
            operator); The first field of the resulting pair is the minimum,
            the second field is the maximum element. If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="minmax_by">
        <div class="fheader">
            <span class="fname">minmax_by()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Function, typename Less = std::less&lt;void&gt;&gt;
auto minmax_by(Function&& function, Less&& less = Less());</code>
            </pre>

            Returns a stream terminator that returns the elements of the stream that result in the smallest
            and largest values of the given function as determined by the provided less than operator (by
            default, the built in <span class="inline">&lt;</span> operator); The first field of the resulting
            pair is the element that minimizes the function, and the second field is the element that maximizes
            it; If the stream is empty, throws an <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="first">
        <div class="fheader">
            <span class="fname">first()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto first();</code>
            </pre>

            Returns a stream terminator that returns the first element of the stream. If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="last">
        <div class="fheader">
            <span class="fname">last()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto last();</code>
            </pre>

            Returns a stream terminator that returns the last element of the stream. If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
        </div>
    </div>

    <div class="function terminator" id="nth">
        <div class="fheader">
            <span class="fname">nth()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto nth(size_t index);</code>
            </pre>

            Returns a stream terminator that returns the n<sup>th</sup> element of the stream, indexed starting at 0. If the
            stream does not contain that many elements, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
            Calling <span class="inline">stream | nth(n)</span> is functionally
            equivalent to calling <span class="inline">stream | skip(n) | first()</span>.
        </div>
    </div>

    <div class="function terminator" id="reduce">
        <div class="fheader">
            <span class="fname">reduce()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures (template definitions
            excluded for brevity):</span>
            <pre>
                <code lang="C++">auto reduce(Accumulator&& accum);
auto reduce(IdentityFn&& identityFn, Accumulator&& accum);
</code>
            </pre>

            Returns a stream terminator that performs an identity-less reduction
            (or a fold) of the elements in the stream. Since there is no identity value
            for each of these, if the stream is empty an <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>
            is thrown. There are two forms of the reduce operation, given by the signatures above.<br/><br/>

            The first reduce operation has an accumulator takes both arguments of the stream type
            and returns a value of the same type. The functionality is equivalent to (in pseudocode):

            <pre>
                <code lang="C++">T result = stream[0];
for(T element : stream[1 ...]) {
    result = accum(result, element);
}
return result;</code>
            </pre>

            This reduce operation can be used to compute a sum without identity:

            <pre>
                <code lang="C++">stream | reduce(std::add&lt;void&gt;());</code>
            </pre>

            The second reduce operation takes an identity function which converts
            elements of the stream into elements of the result type, and an accumulator
            which takes a first argument of the result type, and a second argument of
            the result type. The functionality is equivalent to (in
            pseudocode):
            <pre>
                <code lang="C++">U result = identity(stream[0]);
for(T element : stream[1...]) {
    result = accum(result, element);
}
return result;</code>
            </pre>

            This is the type of reduction that is used to compute
            <span class="inline">minmax()</span>, which can be implemented as
            follows:

            <pre>
                <code lang="C++">auto to_pair = [](auto&& x) {
    return std::make_pair(x, x);
};

auto next_minmax = [](auto&& prev_minmax, auto&& value) {
    if(value &lt; prev_minmax.first) {
        return std::make_pair(value, prev_minmax.second);
    } else if (value &gt; prev_minmax.second) {
        return std::make_pair(prev_minmax.first, value);
    } else {
        return prev_minmax;
    }
};

auto minmax = reduce(to_pair, next_minmax);</code>
            </pre>

        </div>
    </div>

    <div class="function terminator" id="identity_reduce">
        <div class="fheader">
            <span class="fname">identity_reduce()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename U, typename Accumulator&gt;
auto identity_reduce(const U& identity, Accumulator&& accumulator);</code>
            </pre>

            Returns a stream terminator that performs a reduction with an identity element.
            If the stream is empty, then the identity value is returned. The accumulator
            function works the same as it does for <span class="inline"><a href="#reduce">reduce</a></span>,
            the first argument is the result type, the second argument is the stream type.
            The functionality is equivalent to:

            <pre>
                <code lang="C++">U result = identity
for(T element : stream) {
    result = accum(result, element);
}
return result;</code>
            </pre>
        </div>
    </div>

    <div class="function terminator" id="random_element">
        <div class="fheader">
            <span class="fname">random_element()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto random_element();</code>
            </pre>

            Returns a stream terminator that returns a random element drawn uniformly from the elements of the stream.
            If the stream is empty, throws an
            <span class="inline"><a href="#emptyexception">EmptyStreamException</a></span>.
            If the stream is infinite, this will never terminate.
        </div>
    </div>

    <div class="function terminator" id="random_sample">
        <div class="fheader">
            <span class="fname">random_sample()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto random_sample(size_t size);</code>
            </pre>

            Returns a stream terminator that returns a vector containing a random sample of elements of the given size drawn randomly
            from the stream. If the stream has less elements than the requested size,
            the sample will consist of all of the elements of the stream. If the
            stream is infinite, this will never terminate.</span>
        </div>
    </div>

    <div class="function terminator" id="any">
        <div class="fheader">
            <span class="fname">any()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Predicate&gt;
auto any(Predicate&& predicate);</code>
            </pre>

            Returns a stream terminator that returns true if some element of the stream matches the given predicate.
            If the stream is empty, the result is vacuously false. If the stream is
            infinite, this operation will shortcut in the case that an element that
            matches the predicate is found.<br/><br/>

            <b>Specializations:</b><br/><br/>

            A specialization of <span class="inline">any()</span> exists for types
            that have an implicit conversion to <span class="inline">bool</span>.
            For these types, the following specialization exists:

            <pre>
                <code lang="C++">auto any();</code>
            </pre>

            This returns true if any element of the stream has a conversion to a
            <span class="inline">bool</span> with value true.
        </div>
    </div>

    <div class="function terminator" id="all">
        <div class="fheader">
            <span class="fname">all()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Predicate&gt;
auto all(Predicate&& predicate);</code>
            </pre>

            Returns a stream terminator that returns true if all of the elements of the stream matches the given predicate.
            If the stream is empty, the result is vacuously true. If the stream is
            infinite, this operation will shortcut in the case that an element that
            doesn't match the predicate is found.<br/><br/>

            <b>Specializations:</b><br/><br/>

            Specializations of <span class="inline">any()</span> exist for types
            that have an implicit conversion to <span class="inline">bool</span>.
            For these types, the following specializations exist:

            <pre>
                <code lang="C++">auto all();</code>
            </pre>

            The first returns true if all of the elements of the stream have a conversion to a
            <span class="inline">bool</span> with value true. The second is a convenience for
            the logical not of the first.
        </div>
    </div>

    <div class="function terminator" id="none">
        <div class="fheader">
            <span class="fname">none()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Predicate&gt;
auto none(Predicate&& predicate);</code>
            </pre>

            Returns a stream terminator that returns true if none of the elements of the stream matches the given predicate.
            If the stream is empty, the result is vacuously true. If the stream is
            infinite, this operation will shortcut in the case that an element that
            doesn't match the predicate is found.<br/><br/>

            <b>Specializations:</b><br/><br/>

            A specialization of <span class="inline">none()</span> exists for types
            that have an implicit conversion to <span class="inline">bool</span>.
            For these types, the following specialization exists:

            <pre>
                <code lang="C++">auto none();</code>
            </pre>

            This returns true if none of the elements of the stream have a conversion to a
            <span class="inline">bool</span> with value true.
        </div>
    </div>

    <div class="function terminator" id="not_all">
        <div class="fheader">
            <span class="fname">not_all()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Predicate&gt;
auto not_all(Predicate&& predicate);</code>
            </pre>

            Returns a stream terminator that returns true if not all of the elements of the stream matches the given predicate.
            If the stream is empty, the result is vacuously true. If the stream is
            infinite, this operation will shortcut in the case that an element that
            doesn't match the predicate is found.<br/><br/>

            <b>Specializations:</b><br/><br/>

            A specialization of <span class="inline">not_all()</span> exists for types
            that have an implicit conversion to <span class="inline">bool</span>.
            For these types, the following specialization exists:

            <pre>
                <code lang="C++">auto not_all();</code>
            </pre>

            This returns true if not all of the elements of the stream have a conversion to a
            <span class="inline">bool</span> with value true.
        </div>
    </div>

    <div class="function terminator" id="for_each">
        <div class="fheader">
            <span class="fname">for_each()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename Function&gt;
auto for_each(Function&& function);</code>
            </pre>

            Returns a stream terminator that calls the given function on each element of the stream.
        </div>
    </div>

    <div class="function terminator" id="to_container">
        <div class="fheader">
            <span class="fname">to_<i>container</i>()</span>
            <span class="fdescriptor">Stateful terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signatures:</span>
            <pre>
                <code lang="C++">auto to_vector();
auto to_list();
auto to_deque();
auto to_set();
auto to_multiset();
auto to_unordered_set();
auto to_unordered_multiset();</code>
            </pre>

            Returns a stream terminator that creates a container of the given type and inserts the elements of the
            stream into that container thereafter returning the contianer. In addition, the
            <span class="inline">Stream</span> class contains conversion operators for each of the above container
            types. For example, the following two lines are equivalent

            <pre>
                <code lang="C++">std::vector&lt;int&gt; result = stream;
auto result = stream | to_vector();</code>
            </pre>
        </div>
    </div>

    <div class="function terminator" id="copy_to">
        <div class="fheader">
            <span class="fname">copy_to()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename OutputIterator&gt;
auto copy_to(OutputIterator iterator);</code>
            </pre>

            Returns a stream terminator that copies the elements of the stream into the given iterator, returning
            the iterator one past the end of the sequence, much like
            <span class="inline">std::copy</span>.
        </div>
    </div>

    <div class="function terminator" id="move_to">
        <div class="fheader">
            <span class="fname">move_to()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">template&lt;typename OutputIterator&gt;
auto move_to(OutputIterator iterator);</code>
            </pre>

            Returns a stream terminator that moves the elements of the stream into the given iterator, returning
            the iterator one past the end of the sequence, much like
            <span class="inline">std::move</span> (the one in the algorithm package).
        </div>
    </div>

    <div class="function terminator" id="print_to">
        <div class="fheader">
            <span class="fname">print_to()</span>
            <span class="fdescriptor">Stateless terminal stream operator</span>
        </div>
        <div class="fcontent">
            <span class="signature">Method signature:</span>
            <pre>
                <code lang="C++">auto print_to(std::ostream& os, const char* delimiter = ' ');</code>
            </pre>

            Returns a stream terminator that prints the elements of the stream to the given
            <span class="inline">ostream</span>, with a delimiter after every element. The return value
            is simply the input stream, thus allowing chaining of stream insertions.
            Calling <span class="inline">stream | print_to(os, delimiter)</span> is a convenience method for:

            <pre>
                <code lang="C++">stream | copy_to(std::ostream_iterator&lt;T&gt;(os, delimiter));
return os;</code>
            </pre>
        </div>
    </div>

    <h2 id="reducers">Stream Reducers</h2>

    Stream Reducers are class that provide convenient common reductions of streams for a variety of types.

    <div class="function reducers" id="reducer">
        <div class="fheader">
            <span class="fname">Reducer</span>
            <span class="fdescriptor">Stream reducer</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">template&lt;typename In, typename Out&gt;
class Reducer {
    virtual Out initial(In&& in) const = 0;
    virtual Out accumulate(Out&& out, In&& in) const = 0;
    auto reducer() const;
}</code>
            </pre>
            Reducers provide the two main functions provided to the
            <a href="#reduce"><span class="inline">reduce()</span></a> terminator as class methods
            for a subclass to overload. One constructs an instance of a reducer subclass and then
            calls the <span class="inline">reducer()</span> method to turn it into a terminal operation
            that reduces a stream using the desired functions.
            <br><br>
            Reducers are not included when you include <span class="inline">"Stream.h"</span>, you
            must additionally include <span class="inline">"Reducers.h"</span> to get them.
        </div>
    </div>

    <div class="function reducers" id="histogram">
        <div class="fheader">
            <span class="fname">Histogram</span>
            <span class="fdescriptor">Stream reducer</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">template&lt;typename In, typename Less = std::less&lt;In&gt;&gt;
class Histogram : public Histogram&lt;In, std::map&lt;In, size_t, Less&gt;&gt; {
public:
    Histogram(Less&& less = Less());
}</code>
            </pre>

            A reducer that accumulate the contents of a stream by counting the occurences of each
            item that's tconsidered distinct by the given comparison operator.

            <br><br>
            <i>Example:</i>

            <pre>
                <code lang="C++">std::map&lt;int, int&gt; result = MakeStream::from({1, 3, 1, 2, 1, 2}
    | reducer::Histogram&lt;int&gt;().reducer();
// result contains {1: 3, 2: 2, 3: 1}</code>
            </pre>
        </div>
    </div>

    <div class="function reducers" id="summarystats">
        <div class="fheader">
            <span class="fname">SummaryStats</span>
            <span class="fdescriptor">Stream reducer</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">template&lt;typename In, typename Result = double&gt;
class SummaryStats : public Reducer&lt;In, Stats&lt;In, Result&gt;&gt; {
}

template&lt;typename In, typename Out&gt;
class Stat {
    size_t number() const;
    Out mean() const;
    Out stddev() const;
    In min() const;
    In max() const;
};</code>
            </pre>

            A reducer that accumulates various summary statistics about the input data,
            and returns a statistics object containing those.

            <br><br>
            <i>Example:</i>

            <pre>
                <code lang="C++">auto stats = MakeStream::normal_randoms()
    | limit(1000)
    | reducers::SummaryStats&lt;int&gt;().reducer();
std::cout << stats << std::endl;
// Example output: N=1000, u=0.015, s=0.473248, min=-3, max=3</code>
            </pre>
        </div>
    </div>

    <h2 id="exceptions">Stream Exceptions</h2>

    <div class="function exception" id="streamexception">
        <div class="fheader">
            <span class="fname">StreamException</span>
            <span class="fdescriptor">Stream exception</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">class StreamException {
public:
    explicit StreamException(const std::string& msg);
    explicit StreamException(const char* msg);

    std::string what() const;
}</code>
            </pre>

            The root class of all stream based exceptions.
        </div>
    </div>

    <div class="function exception" id="emptyexception">
        <div class="fheader">
            <span class="fname">EmptyStreamException</span>
            <span class="fdescriptor">Stream exception</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">class EmptyStreamException : public StreamException {
public:
    explicit EmptyStreamException(const std::string& method);
}</code>
            </pre>

            The exception that gets thrown when attempting to call some terminal
            stream operation that has no identity element for that operation on
            a stream that is empty.
            <br/><br/>

            <i>Example:</i>

            <pre>
                <code lang="C++">try {
    MakeStream::empty<int>() | min()
} catch(EmptyStreamException& e) {
    std::cout << e.what() << std::endl;
}</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">No terminal result for operation stream::op::min.</code>
            </pre>
        </div>
    </div>

    <div class="function exception" id="vacantexception">
        <div class="fheader">
            <span class="fname">VacantStreamException</span>
            <span class="fdescriptor">Stream exception</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">class VacantStreamException : public StreamException {
public:
    explicit EmptyStreamException(const std::string& method);
}</code>
            </pre>

            The exception that gets thrown when attempting to call any stream operation
            on some stream that no longer holds data. A stream is considered vacant when
            it has been moved from some other stream, or some stream operation has been
            called on the stream. To check vacancy, use the <span class="inline">
            <a href="#occupied">occupied()</a></span> method.
            <br/><br/>

            <i>Example:</i>

            <pre>
                <code lang="C++">auto stream1 = MakeStream::range(0, 5);
auto stream2 = std::move(stream1); // Copying disallowed
try {
    stream1 | skip(2);
} catch(VacantStreamException& e) {
    std::cout << e.what() << std::endl;
}
stream2 | skip(2); // Didn't save it so stream2's data is lost!
try {
    stream2 | first();
} catch(VacantStreamException& e) {
    cout << e.what() << endl;
}</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">Cannot perform operation stream::op::skip on a vacant stream
Cannot perform operation stream::op::first on a vacant stream</code>
            </pre>
        </div>
    </div>

    <div class="function exception" id="consumedexception">
        <div class="fheader">
            <span class="fname">ConsumedIteratorException</span>
            <span class="fdescriptor">Stream exception</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">class ConsumedIteratorException : public StreamException {
public:
    explicit ConsumedIteratorException(const std::string& op);
}</code>
            </pre>

            The exception that gets thrown when attempting to call some non dereferencing
            operation on a stream iterator after that iterator is declared to be
            in a "consumed" state. For a discussion of this, see the comments for
            the <span class="inline"><a href="#begin">begin()</a></span> method.
            <br/><br/>

            <i>Example:</i>

            <pre>
                <code lang="C++">auto stream = MakeStream::closed_range(1,10);
auto iter = stream.begin();
cout << *iter << endl;
auto temp_iter = iter++;
cout << *temp_iter << endl;
try {
    ++temp_iter;
} catch(ConsumedIteratorException& e) {
    cout << e.what() << endl;
}</code>
            </pre>

            Produces the following output:

            <pre>
                <code class="output">1
2
Cannot perform prefix increment on consumed stream iterator.</code>
            </pre>
        </div>
    </div>

    <div class="function exception" id="stopstream">
        <div class="fheader">
            <span class="fname">StopStream</span>
            <span class="fdescriptor">Stream exception</span>
        </div>
        <div class="fcontent">
            <span class="signature">Class signature:</span>
            <pre>
                <code lang="C++">class StopStream : public StreamException {
public:
    explicit StopStream();
}</code>
            </pre>

            An exception to be thrown by the user in any intermediary or generating
            (but not terminating) stream operation, if they want the stream to stop
            iterating at that point. This is most often helpful with the
            <span class="inline"><a href="#generate">generate()</a></span>
            method.
            <br/><br/>

            <i>Example:</i>

            <pre>
                <code lang="C++">std::ifstream fin = /* ... */
auto stream = MakeStream::generate([&fin]() {
    std::string line;
    if(!std::getline(fin, line))
        throw StopStream(); // Stop iterating when we reach EOF
    return line;
});</code>
            </pre>

            <pre>
                <code lang="C++">// Silly version of take while
stream | peek([](auto& value) {
    if(!pred(value))
        throw StopStream();
});</code>
            </pre>
        </div>
    </div>

    <h2 id="recipes">Stream Recipes</h2>

    These will go here eventually.

    <hr/>

    <p>
    C++ Streams are developed by David Godfrey.
    Please <a href="mailto:david.godfrey99@gmail.com">contact</a> me if you have question or concerns.</p>

    <p class="license">C++ Streams are distributed under the <a href="http://opensource.org/licenses/MIT" target="blank">MIT open source license</a>.</p>

    <p class="license">Copyright &copy; 2022 by David Godfrey</p>
</div>

</body>
</html>

